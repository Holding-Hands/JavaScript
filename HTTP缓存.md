### HTTP缓存

在任何一个前端项目中，访问服务器获取数据都是很常见的事情，但是如果相同数据被重复请求了不止一次，那么多余的请求次数必然会浪费网络带宽，以及延迟浏览器渲染所要处理的内容，从而影响用户体验，如果用户使用的是按量计费的方式访问网络，那么多余的请求还会增加用户流量费用，一次使用缓存技术对已获取的资源进行重用，是一种提升网站性能与用户体验的有效策略。

缓存的原理在首次请求保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，避免重新向服务器发送请求。

缓存技术有很多种，比如代理缓存、浏览器缓存、网关缓存、负载均衡器以及内容分发网络等，大致分为两类：共享缓存和私有缓存。

* 共享缓存指的是缓存内容可以被多个用户使用，如公司内部架设的web代理。
* 私有缓存指的是缓存内容只能被一个用户使用，比如浏览器缓存。

### 1. 什么是HTTP缓存？

* Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。
* 浏览器第一次打开一个网站的时候，需要加载对应资源，比如css，html，js，图片等,浏览器给我们缓存
* 浏览器第一次之后打开同样的一个网站，并不是把所有资源都加载过来，而是通过缓存帮助我们加载一些资源，整体网站的速度加载很快
* 强制缓存与协商缓存最大区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问，进而判断是否需要就响应内容进行重新请求



### 2. 协商缓存

#### 2.1  什么是协商缓存

* 协商缓存就是在使用本地缓存之前，需要向服务器端发起一次get请求，与之协商当前浏览器保存的本地缓存是否过期。如果无效服务器会发送最新的资源内容。

#### 2.2 协商缓存的2种实现方式

* 第一种方式：**Cache-Control** 和 **Last-Modified**方式

  * 服务器设置**Last-Modified**: GMT格式的时间，**Cache-Control**：no-cache
  * 第一次向服务器请求时，服务器给客户端返回资源和Last-Modified，浏览器会把返回的资源存在本地缓存中
  * 下次再请求的时候，在请求头中添加`if-Modified-since`(Last-Modified)，服务器根据这个`if-Modified-since`的值（修改时间）来判断是否过期，如果时间和服务器修改时间相同说明本地缓存没过期，不相同说明本地缓存的资源被修改了，本地缓存就过期了
  * 如果缓存过期了，服务器返回200状态码，更新最新的资源和资源标识，这就相当于发了一次完整请求，请求也会变慢
  * 如果缓存没过期，服务器返回304状态码，客户端就会去本地缓存中拿资源，服务器只给客户端返回304，不需要返回文件，这次请求资源就是很小的
  * 通过这种方式实现的协商缓存，有两个缺点
    * 首先它只是根据资源最后修改时间戳进行判断的，虽然请求的文件资源进行了编辑（只改图片名字），但是内容没有发生变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新请求资源，会造成带宽的浪费，以及延长用户获取目标资源的时间
    * 其次标识文件资源修改的时间戳单位是秒（无法精确到毫秒），如果文件修改速度非常快，假设在几百毫秒内完成，哪么上述通过时间戳方式验证缓存的有效性，是无法识别出该次文件资源的更新的。
  * 造成这两个原因相同，就是服务器无法仅依据资源修改的时间戳来识别真正的更新，进而导致重新发起请求该请求却使用了缓存的bug

  

* 第二种方式：**ETag**协商缓存

  * 为了弥补通过时间戳判断的不足，从http1.1规范开始新增一个ETag的头信息，即实体标签（Entity Tag）
  * 主要内容是服务器为不同资源进行哈希运算生成一个字符串，该字符串类似文件指纹，只要文件内容编码存在差异，对应的ETag标签值就会不同，因此可以使用ETag对文件资源进行更准确的变化感知。（其实就是修改文件名哈希值不会变，修改内容这个哈希值才会变，弥补了第一种方式的缺陷）
  * 再第一种方法基础上服务器设置**Last-Modified**: GMT格式的时间，**Cache-Contro**：no-cache，**Etag**：根据文件内容生成ETag
  * 下次再请求的时候，除了带上`if-Modified-since`(Last-Modified)，还会带上资源标识`if-None-Match`(ETag)，服务器根据这个标识判断，本地缓存资源是否和服务器资源相同，相同返回304状态码，使用本地缓存没过期，不相同，返回200状态码，在返回新的资源保存到本地缓存
  * ETag的弊端：
    * 一方面服务器生成资源文件的ETag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成ETag的过程就会影响服务器的性能。
    * 另一方面ETag字段值的生成分为强验证和弱验证，强验证根据资源内容生成，能够保证每个字节都相同。弱验证则根据资源部分属性值来生成，生成速度快但无法保证每个字节都相同，并且再服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以适当的方式是根据资源使用的场景选择恰当的缓存校验方式。

  

### 3. 强制缓存

* 强缓存是利用http的返回头中的**Expires**或者**Cache-Control**两个字段来控制的，用来表示资源的缓存时间。
* Expires字段会返回一个时间，比如Expires:Thu,31 Dec 2020 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2020年12月31日23点59分59秒之前都是有效的。但有一个明显的缺点，由于失效时间是一个绝对时间，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。

* Cache-Control是一个相对时间，例如Cache-Control: max-age: 31536000，代表着资源的有效期是31536000秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。
* 客户端在第一次请求的时候，浏览器会给客户端返回资源，如果服务器觉得资源有必要缓存，会在响应头(response header)加上`Cache-Control`,可以设置max-age(31536000秒，对应一年)或者no-cache，
* Cache-Control 可以由多个字段组合而成，主要有以下几个取值：
  * **max-age**
    * 下一次请求的时候，会去根据max-age检查本地缓存是否过期，如果没有过期不会发送请求，从缓存里拿资源，页面加载速度很快，不需要请求，http请求是不稳定的，如果网络状态不好，可能等好几秒。此时状态码变为Status Code: 200 OK(from memory cache)
    * 如果本地缓存过期了，那么会去服务器重新发送请求，返回资源
  * **no-cache**，表示强制进行协商缓存，每次请求与服务器协商判断本地缓存有效性，如果未过期使用本地缓存。
  * **no-store** 禁止使用任何缓存策略，每次请求都要向服务器重新获取数据。
  * **no-cache** 与 **no-store** 是互斥属性不能同时设置。
  * **private** 表明响应只能被浏览器缓存，是非共享的，不能被代理服务器缓存，若未显示指定默认值为private。
  * **public** 表明响应既可以被浏览器缓存，也可以被代理服务器缓存。
  * **private** 与 **public** 是互斥属性不能同时设置，他们用于明确相应资源能否可被代理服务器进行缓存。
  * **must-revalidate**指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。
* Cache-Control是服务器来通过响应投来决定的

* 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age，需要和Last-modified结合使用。但cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。



